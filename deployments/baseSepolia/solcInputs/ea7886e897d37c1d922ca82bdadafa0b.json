{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert Errors.FailedCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ICircleBridge.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\r\npragma solidity ^0.8.19;\r\n\r\nimport {IMessageTransmitter} from \"./IMessageTransmitter.sol\";\r\nimport {ITokenMinter} from \"./ITokenMinter.sol\";\r\n\r\ninterface ICircleBridge {\r\n    /**\r\n     * @notice Deposits and burns tokens from sender to be minted on destination domain.\r\n     * Emits a `DepositForBurn` event.\r\n     * @dev reverts if:\r\n     * - given burnToken is not supported\r\n     * - given destinationDomain has no CircleBridge registered\r\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\r\n     * to this contract is less than `amount`.\r\n     * - burn() reverts. For example, if `amount` is 0.\r\n     * - MessageTransmitter returns false or reverts.\r\n     * @param _amount amount of tokens to burn\r\n     * @param _destinationDomain destination domain (ETH = 0, AVAX = 1)\r\n     * @param _mintRecipient address of mint recipient on destination domain\r\n     * @param _burnToken address of contract to burn deposited tokens, on local domain\r\n     * @return _nonce unique nonce reserved by message\r\n     */\r\n    function depositForBurn(uint256 _amount, uint32 _destinationDomain, bytes32 _mintRecipient, address _burnToken)\r\n        external\r\n        returns (uint64 _nonce);\r\n\r\n    /**\r\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\r\n     * on the destination domain must be called by `_destinationCaller`.\r\n     * WARNING: if the `_destinationCaller` does not represent a valid address as bytes32, then it will not be possible\r\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\r\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\r\n     * Emits a `DepositForBurn` event.\r\n     * @dev reverts if:\r\n     * - given destinationCaller is zero address\r\n     * - given burnToken is not supported\r\n     * - given destinationDomain has no CircleBridge registered\r\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\r\n     * to this contract is less than `amount`.\r\n     * - burn() reverts. For example, if `amount` is 0.\r\n     * - MessageTransmitter returns false or reverts.\r\n     * @param _amount amount of tokens to burn\r\n     * @param _destinationDomain destination domain\r\n     * @param _mintRecipient address of mint recipient on destination domain\r\n     * @param _burnToken address of contract to burn deposited tokens, on local domain\r\n     * @param _destinationCaller caller on the destination domain, as bytes32\r\n     * @return _nonce unique nonce reserved by message\r\n     */\r\n    function depositForBurnWithCaller(\r\n        uint256 _amount,\r\n        uint32 _destinationDomain,\r\n        bytes32 _mintRecipient,\r\n        address _burnToken,\r\n        bytes32 _destinationCaller\r\n    ) external returns (uint64 _nonce);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function handleReceiveMessage(uint32 _remoteDomain, bytes32 _sender, bytes memory messageBody)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function localMessageTransmitter() external view returns (IMessageTransmitter);\r\n\r\n    function localMinter() external view returns (ITokenMinter);\r\n\r\n    function remoteCircleBridges(uint32 domain) external view returns (bytes32);\r\n\r\n    // owner only methods\r\n    function transferOwnership(address newOwner) external;\r\n}"
    },
    "contracts/interfaces/ICircleIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\r\n\r\npragma solidity ^0.8.19;\r\n\r\nimport {IWormhole} from \"./IWormhole.sol\";\r\nimport {ICircleBridge} from \"./ICircleBridge.sol\";\r\nimport {IMessageTransmitter} from \"./IMessageTransmitter.sol\";\r\n\r\ninterface ICircleIntegration {\r\n    struct TransferParameters {\r\n        address token;\r\n        uint256 amount;\r\n        uint16 targetChain;\r\n        bytes32 mintRecipient;\r\n    }\r\n\r\n    struct RedeemParameters {\r\n        bytes encodedWormholeMessage;\r\n        bytes circleBridgeMessage;\r\n        bytes circleAttestation;\r\n    }\r\n\r\n    struct DepositWithPayload {\r\n        bytes32 token;\r\n        uint256 amount;\r\n        uint32 sourceDomain;\r\n        uint32 targetDomain;\r\n        uint64 nonce;\r\n        bytes32 fromAddress;\r\n        bytes32 mintRecipient;\r\n        bytes payload;\r\n    }\r\n\r\n    function transferTokensWithPayload(TransferParameters memory transferParams, uint32 batchId, bytes memory payload)\r\n        external\r\n        payable\r\n        returns (uint64 messageSequence);\r\n\r\n    function redeemTokensWithPayload(RedeemParameters memory params)\r\n        external\r\n        returns (DepositWithPayload memory depositWithPayload);\r\n\r\n    function fetchLocalTokenAddress(uint32 sourceDomain, bytes32 sourceToken)\r\n        external\r\n        view\r\n        returns (bytes32);\r\n\r\n    function encodeDepositWithPayload(DepositWithPayload memory message) external pure returns (bytes memory);\r\n\r\n    function decodeDepositWithPayload(bytes memory encoded) external pure returns (DepositWithPayload memory message);\r\n\r\n    function isInitialized(address impl) external view returns (bool);\r\n\r\n    function wormhole() external view returns (IWormhole);\r\n\r\n    function chainId() external view returns (uint16);\r\n\r\n    function wormholeFinality() external view returns (uint8);\r\n\r\n    function circleBridge() external view returns (ICircleBridge);\r\n\r\n    function circleTransmitter() external view returns (IMessageTransmitter);\r\n\r\n    function getRegisteredEmitter(uint16 emitterChainId) external view returns (bytes32);\r\n\r\n    function isAcceptedToken(address token) external view returns (bool);\r\n\r\n    function getDomainFromChainId(uint16 chainId_) external view returns (uint32);\r\n\r\n    function getChainIdFromDomain(uint32 domain) external view returns (uint16);\r\n\r\n    function isMessageConsumed(bytes32 hash) external view returns (bool);\r\n\r\n    function localDomain() external view returns (uint32);\r\n\r\n    function verifyGovernanceMessage(bytes memory encodedMessage, uint8 action)\r\n        external\r\n        view\r\n        returns (bytes32 messageHash, bytes memory payload);\r\n\r\n    function evmChain() external view returns (uint256);\r\n\r\n    // guardian governance only\r\n    function updateWormholeFinality(bytes memory encodedMessage) external;\r\n\r\n    function registerEmitterAndDomain(bytes memory encodedMessage) external;\r\n\r\n    function upgradeContract(bytes memory encodedMessage) external;\r\n}"
    },
    "contracts/interfaces/IMessageTransmitter.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\r\npragma solidity ^0.8.19;\r\n\r\ninterface IMessageTransmitter {\r\n    event MessageSent(bytes message);\r\n\r\n    /**\r\n     * @notice Emitted when tokens are minted\r\n     * @param _mintRecipient recipient address of minted tokens\r\n     * @param _amount amount of minted tokens\r\n     * @param _mintToken contract address of minted token\r\n     */\r\n    event MintAndWithdraw(address _mintRecipient, uint256 _amount, address _mintToken);\r\n\r\n    /**\r\n     * @notice Receive a message. Messages with a given nonce\r\n     * can only be broadcast once for a (sourceDomain, destinationDomain)\r\n     * pair. The message body of a valid message is passed to the\r\n     * specified recipient for further processing.\r\n     *\r\n     * @dev Attestation format:\r\n     * A valid attestation is the concatenated 65-byte signature(s) of exactly\r\n     * `thresholdSignature` signatures, in increasing order of attester address.\r\n     * ***If the attester addresses recovered from signatures are not in\r\n     * increasing order, signature verification will fail.***\r\n     * If incorrect number of signatures or duplicate signatures are supplied,\r\n     * signature verification will fail.\r\n     *\r\n     * Message format:\r\n     * Field Bytes Type Index\r\n     * version 4 uint32 0\r\n     * sourceDomain 4 uint32 4\r\n     * destinationDomain 4 uint32 8\r\n     * nonce 8 uint64 12\r\n     * sender 32 bytes32 20\r\n     * recipient 32 bytes32 52\r\n     * messageBody dynamic bytes 84\r\n     * @param _message Message bytes\r\n     * @param _attestation Concatenated 65-byte signature(s) of `_message`, in increasing order\r\n     * of the attester address recovered from signatures.\r\n     * @return success bool, true if successful\r\n     */\r\n    function receiveMessage(bytes memory _message, bytes calldata _attestation) external returns (bool success);\r\n\r\n    function attesterManager() external view returns (address);\r\n\r\n    function availableNonces(uint32 domain) external view returns (uint64);\r\n\r\n    function getNumEnabledAttesters() external view returns (uint256);\r\n\r\n    function isEnabledAttester(address _attester) external view returns (bool);\r\n\r\n    function localDomain() external view returns (uint32);\r\n\r\n    function maxMessageBodySize() external view returns (uint256);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function paused() external view returns (bool);\r\n\r\n    function pauser() external view returns (address);\r\n\r\n    function rescuer() external view returns (address);\r\n\r\n    function version() external view returns (uint32);\r\n\r\n    // owner only methods\r\n    function transferOwnership(address newOwner) external;\r\n\r\n    function updateAttesterManager(address _newAttesterManager) external;\r\n\r\n    // attester manager only methods\r\n    function getEnabledAttester(uint256 _index) external view returns (address);\r\n\r\n    function disableAttester(address _attester) external;\r\n\r\n    function enableAttester(address _attester) external;\r\n\r\n    function setSignatureThreshold(uint256 newSignatureThreshold) external;\r\n}"
    },
    "contracts/interfaces/IPolicy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\r\npragma solidity ^0.8.27;\r\ninterface IPolicy {\r\n\r\n    function policy() external view returns (address);\r\n\r\n    function renouncePolicy() external;\r\n  \r\n    function pushPolicy( address newPolicy_ ) external;\r\n\r\n    function pullPolicy() external;\r\n}"
    },
    "contracts/interfaces/ITokenBridge.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\r\n\r\npragma solidity ^0.8.27;\r\n\r\nimport \"./IWETH.sol\";\r\nimport \"./IWormhole.sol\";\r\n\r\ninterface ITokenBridge {\r\n    struct Transfer {\r\n        uint8 payloadID;\r\n        uint256 amount;\r\n        bytes32 tokenAddress;\r\n        uint16 tokenChain;\r\n        bytes32 to;\r\n        uint16 toChain;\r\n        uint256 fee;\r\n    }\r\n\r\n    struct TransferWithPayload {\r\n        uint8 payloadID;\r\n        uint256 amount;\r\n        bytes32 tokenAddress;\r\n        uint16 tokenChain;\r\n        bytes32 to;\r\n        uint16 toChain;\r\n        bytes32 fromAddress;\r\n        bytes payload;\r\n    }\r\n\r\n    struct AssetMeta {\r\n        uint8 payloadID;\r\n        bytes32 tokenAddress;\r\n        uint16 tokenChain;\r\n        uint8 decimals;\r\n        bytes32 symbol;\r\n        bytes32 name;\r\n    }\r\n\r\n    struct RegisterChain {\r\n        bytes32 module;\r\n        uint8 action;\r\n        uint16 chainId;\r\n\r\n        uint16 emitterChainID;\r\n        bytes32 emitterAddress;\r\n    }\r\n\r\n     struct UpgradeContract {\r\n        bytes32 module;\r\n        uint8 action;\r\n        uint16 chainId;\r\n\r\n        bytes32 newContract;\r\n    }\r\n\r\n    struct RecoverChainId {\r\n        bytes32 module;\r\n        uint8 action;\r\n\r\n        uint256 evmChainId;\r\n        uint16 newChainId;\r\n    }\r\n\r\n    event ContractUpgraded(address indexed oldContract, address indexed newContract);\r\n\r\n    function _parseTransferCommon(bytes memory encoded) external pure returns (Transfer memory transfer);\r\n\r\n    function attestToken(address tokenAddress, uint32 nonce) external payable returns (uint64 sequence);\r\n\r\n    function wrapAndTransferETH(uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) external payable returns (uint64 sequence);\r\n\r\n    function wrapAndTransferETHWithPayload(uint16 recipientChain, bytes32 recipient, uint32 nonce, bytes memory payload) external payable returns (uint64 sequence);\r\n\r\n    function transferTokens(address token, uint256 amount, uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) external payable returns (uint64 sequence);\r\n\r\n    function transferTokensWithPayload(address token, uint256 amount, uint16 recipientChain, bytes32 recipient, uint32 nonce, bytes memory payload) external payable returns (uint64 sequence);\r\n\r\n    function updateWrapped(bytes memory encodedVm) external returns (address token);\r\n\r\n    function createWrapped(bytes memory encodedVm) external returns (address token);\r\n\r\n    function completeTransferWithPayload(bytes memory encodedVm) external returns (bytes memory);\r\n\r\n    function completeTransferAndUnwrapETHWithPayload(bytes memory encodedVm) external returns (bytes memory);\r\n\r\n    function completeTransfer(bytes memory encodedVm) external;\r\n\r\n    function completeTransferAndUnwrapETH(bytes memory encodedVm) external;\r\n\r\n    function encodeAssetMeta(AssetMeta memory meta) external pure returns (bytes memory encoded);\r\n\r\n    function encodeTransfer(Transfer memory transfer) external pure returns (bytes memory encoded);\r\n\r\n    function encodeTransferWithPayload(TransferWithPayload memory transfer) external pure returns (bytes memory encoded);\r\n\r\n    function parsePayloadID(bytes memory encoded) external pure returns (uint8 payloadID);\r\n\r\n    function parseAssetMeta(bytes memory encoded) external pure returns (AssetMeta memory meta);\r\n\r\n    function parseTransfer(bytes memory encoded) external pure returns (Transfer memory transfer);\r\n\r\n    function parseTransferWithPayload(bytes memory encoded) external pure returns (TransferWithPayload memory transfer);\r\n\r\n    function governanceActionIsConsumed(bytes32 hash) external view returns (bool);\r\n\r\n    function isInitialized(address impl) external view returns (bool);\r\n\r\n    function isTransferCompleted(bytes32 hash) external view returns (bool);\r\n\r\n    function wormhole() external view returns (IWormhole);\r\n\r\n    function chainId() external view returns (uint16);\r\n\r\n    function evmChainId() external view returns (uint256);\r\n\r\n    function isFork() external view returns (bool);\r\n\r\n    function governanceChainId() external view returns (uint16);\r\n\r\n    function governanceContract() external view returns (bytes32);\r\n\r\n    function wrappedAsset(uint16 tokenChainId, bytes32 tokenAddress) external view returns (address);\r\n\r\n    function bridgeContracts(uint16 chainId_) external view returns (bytes32);\r\n\r\n    function tokenImplementation() external view returns (address);\r\n\r\n    function WETH() external view returns (IWETH);\r\n\r\n    function outstandingBridged(address token) external view returns (uint256);\r\n\r\n    function isWrappedAsset(address token) external view returns (bool);\r\n\r\n    function finality() external view returns (uint8);\r\n\r\n    function implementation() external view returns (address);\r\n\r\n    function initialize() external;\r\n\r\n    function registerChain(bytes memory encodedVM) external;\r\n\r\n    function upgrade(bytes memory encodedVM) external;\r\n\r\n    function submitRecoverChainId(bytes memory encodedVM) external;\r\n\r\n    function parseRegisterChain(bytes memory encoded) external pure returns (RegisterChain memory chain);\r\n\r\n    function parseUpgrade(bytes memory encoded) external pure returns (UpgradeContract memory chain);\r\n\r\n    function parseRecoverChainId(bytes memory encodedRecoverChainId) external pure returns (RecoverChainId memory rci);\r\n}"
    },
    "contracts/interfaces/ITokenMinter.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @title ITokenMinter\r\n * @notice interface for minter of tokens that are mintable, burnable, and interchangeable\r\n * across domains.\r\n */\r\ninterface ITokenMinter {\r\n    function burnLimitsPerMessage(address token) external view returns (uint256);\r\n\r\n    function remoteTokensToLocalTokens(bytes32 sourceIdHash) external view returns (address);\r\n}"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IWETH is IERC20 {\r\n    function deposit() external payable;\r\n    function withdraw(uint256 amount) external;\r\n}"
    },
    "contracts/interfaces/IWormhole.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\r\n\r\npragma solidity ^0.8.27;\r\n\r\ninterface IWormhole {\r\n    struct Provider {\r\n        uint16 chainId;\r\n        uint16 governanceChainId;\r\n        bytes32 governanceContract;\r\n    }\r\n\r\n    struct GuardianSet {\r\n        address[] keys;\r\n        uint32 expirationTime;\r\n    }\r\n\r\n    struct Signature {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        uint8 guardianIndex;\r\n    }\r\n\r\n    struct VM {\r\n        uint8 version;\r\n        uint32 timestamp;\r\n        uint32 nonce;\r\n        uint16 emitterChainId;\r\n        bytes32 emitterAddress;\r\n        uint64 sequence;\r\n        uint8 consistencyLevel;\r\n        bytes payload;\r\n        uint32 guardianSetIndex;\r\n        Signature[] signatures;\r\n        bytes32 hash;\r\n    }\r\n\r\n    event LogMessagePublished(address indexed sender, uint64 sequence, uint32 nonce, bytes payload, uint8 consistencyLevel);\r\n\r\n    function publishMessage(\r\n        uint32 nonce,\r\n        bytes memory payload,\r\n        uint8 consistencyLevel\r\n    ) external payable returns (uint64 sequence);\r\n\r\n    function parseAndVerifyVM(bytes calldata encodedVM) external view returns (VM memory vm, bool valid, string memory reason);\r\n\r\n    function verifyVM(VM memory vm) external view returns (bool valid, string memory reason);\r\n\r\n    function verifySignatures(bytes32 hash, Signature[] memory signatures, GuardianSet memory guardianSet) external pure returns (bool valid, string memory reason) ;\r\n\r\n    function parseVM(bytes memory encodedVM) external pure returns (VM memory vm);\r\n\r\n    function getGuardianSet(uint32 index) external view returns (GuardianSet memory) ;\r\n\r\n    function getCurrentGuardianSetIndex() external view returns (uint32) ;\r\n\r\n    function getGuardianSetExpiry() external view returns (uint32) ;\r\n\r\n    function governanceActionIsConsumed(bytes32 hash) external view returns (bool) ;\r\n\r\n    function isInitialized(address impl) external view returns (bool) ;\r\n\r\n    function chainId() external view returns (uint16) ;\r\n\r\n    function governanceChainId() external view returns (uint16);\r\n\r\n    function governanceContract() external view returns (bytes32);\r\n\r\n    function messageFee() external view returns (uint256) ;\r\n}"
    },
    "contracts/interfaces/IWormholeReceiver.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @notice Interface for a contract which can receive Wormhole messages.\r\n */\r\ninterface IWormholeReceiver {\r\n  /**\r\n   * @notice When a `send` is performed with this contract as the target, this function will be\r\n   *     invoked by the WormholeRelayer contract\r\n   *\r\n   * NOTE: This function should be restricted such that only the Wormhole Relayer contract can call it.\r\n   *\r\n   * We also recommend that this function checks that `sourceChain` and `sourceAddress` are indeed who\r\n   *       you expect to have requested the calling of `send` on the source chain\r\n   *\r\n   * The invocation of this function corresponding to the `send` request will have msg.value equal\r\n   *   to the receiverValue specified in the send request.\r\n   *\r\n   * If the invocation of this function reverts or exceeds the gas limit\r\n   *   specified by the send requester, this delivery will result in a `ReceiverFailure`.\r\n   *\r\n   * @param payload - an arbitrary message which was included in the delivery by the\r\n   *     requester. This message's signature will already have been verified (as long as msg.sender is the Wormhole Relayer contract)\r\n   * @param additionalMessages - Additional messages which were requested to be included in this delivery.\r\n   *      Note: There are no contract-level guarantees that the messages in this array are what was requested\r\n   *      so **you should verify any sensitive information given here!**\r\n   *\r\n   *      For example, if a 'VaaKey' was specified on the source chain, then MAKE SURE the corresponding message here\r\n   *      has valid signatures (by calling `parseAndVerifyVM(message)` on the Wormhole core contract)\r\n   *\r\n   *      This field can be used to perform and relay TokenBridge or CCTP transfers, and there are example\r\n   *      usages of this at\r\n   *         https://github.com/wormhole-foundation/hello-token\r\n   *         https://github.com/wormhole-foundation/hello-cctp\r\n   *\r\n   * @param sourceAddress - the (wormhole format) address on the sending chain which requested\r\n   *     this delivery.\r\n   * @param sourceChain - the wormhole chain ID where this delivery was requested.\r\n   * @param deliveryHash - the VAA hash of the deliveryVAA.\r\n   *\r\n   */\r\n  function receiveWormholeMessages(\r\n    bytes memory payload,\r\n    bytes[] memory additionalMessages,\r\n    bytes32 sourceAddress,\r\n    uint16 sourceChain,\r\n    bytes32 deliveryHash\r\n  ) external payable;\r\n}"
    },
    "contracts/interfaces/IWormholeRelayer.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title WormholeRelayer\r\n * @author\r\n * @notice This project allows developers to build cross-chain applications powered by Wormhole without needing to\r\n * write and run their own relaying infrastructure\r\n *\r\n * We implement the IWormholeRelayer interface that allows users to request a delivery provider to relay a payload (and/or additional messages)\r\n * to a chain and address of their choice.\r\n */\r\n\r\n/**\r\n * @notice VaaKey identifies a wormhole message\r\n *\r\n * @custom:member chainId Wormhole chain ID of the chain where this VAA was emitted from\r\n * @custom:member emitterAddress Address of the emitter of the VAA, in Wormhole bytes32 format\r\n * @custom:member sequence Sequence number of the VAA\r\n */\r\nstruct VaaKey {\r\n  uint16 chainId;\r\n  bytes32 emitterAddress;\r\n  uint64 sequence;\r\n}\r\n\r\n// 0-127 are reserved for standardized KeyTypes, 128-255 are for custom use\r\nuint8 constant VAA_KEY_TYPE = 1;\r\n\r\nstruct MessageKey {\r\n  uint8 keyType; // 0-127 are reserved for standardized KeyTypes, 128-255 are for custom use\r\n  bytes encodedKey;\r\n}\r\n\r\ninterface IWormholeRelayerBase {\r\n  event SendEvent(\r\n    uint64 indexed sequence,\r\n    uint256 deliveryQuote,\r\n    uint256 paymentForExtraReceiverValue\r\n  );\r\n\r\n  function getRegisteredWormholeRelayerContract(\r\n    uint16 chainId\r\n  ) external view returns (bytes32);\r\n\r\n  /**\r\n   * @notice Returns true if a delivery has been attempted for the given deliveryHash\r\n   * Note: invalid deliveries where the tx reverts are not considered attempted\r\n   */\r\n  function deliveryAttempted(\r\n    bytes32 deliveryHash\r\n  ) external view returns (bool attempted);\r\n\r\n  /**\r\n   * @notice block number at which a delivery was successfully executed\r\n   */\r\n  function deliverySuccessBlock(\r\n    bytes32 deliveryHash\r\n  ) external view returns (uint256 blockNumber);\r\n\r\n  /**\r\n   * @notice block number of the latest attempt to execute a delivery that failed\r\n   */\r\n  function deliveryFailureBlock(\r\n    bytes32 deliveryHash\r\n  ) external view returns (uint256 blockNumber);\r\n}\r\n\r\n/**\r\n * @title IWormholeRelayerSend\r\n * @notice The interface to request deliveries\r\n */\r\ninterface IWormholeRelayerSend is IWormholeRelayerBase {\r\n  /**\r\n   * @notice Publishes an instruction for the default delivery provider\r\n   * to relay a payload to the address `targetAddress` on chain `targetChain`\r\n   * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\r\n   *\r\n   * `targetAddress` must implement the IWormholeReceiver interface\r\n   *\r\n   * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\r\n   *\r\n   * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendPayloadToEvm` function\r\n   * with `refundChain` and `refundAddress` as parameters\r\n   *\r\n   * @param targetChain in Wormhole Chain ID format\r\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\r\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n   * @param gasLimit gas limit with which to call `targetAddress`.\r\n   * @return sequence sequence number of published VAA containing delivery instructions\r\n   */\r\n  function sendPayloadToEvm(\r\n    uint16 targetChain,\r\n    address targetAddress,\r\n    bytes memory payload,\r\n    uint256 receiverValue,\r\n    uint256 gasLimit\r\n  ) external payable returns (uint64 sequence);\r\n\r\n  /**\r\n   * @notice Publishes an instruction for the default delivery provider\r\n   * to relay a payload to the address `targetAddress` on chain `targetChain`\r\n   * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\r\n   *\r\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\r\n   * `targetAddress` must implement the IWormholeReceiver interface\r\n   *\r\n   * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\r\n   *\r\n   * @param targetChain in Wormhole Chain ID format\r\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\r\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n   * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\r\n   *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\r\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\r\n   * @param refundAddress The address on `refundChain` to deliver any refund to\r\n   * @return sequence sequence number of published VAA containing delivery instructions\r\n   */\r\n  function sendPayloadToEvm(\r\n    uint16 targetChain,\r\n    address targetAddress,\r\n    bytes memory payload,\r\n    uint256 receiverValue,\r\n    uint256 gasLimit,\r\n    uint16 refundChain,\r\n    address refundAddress\r\n  ) external payable returns (uint64 sequence);\r\n\r\n  /**\r\n   * @notice Publishes an instruction for the default delivery provider\r\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\r\n   * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\r\n   *\r\n   * `targetAddress` must implement the IWormholeReceiver interface\r\n   *\r\n   * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\r\n   *\r\n   * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendVaasToEvm` function\r\n   * with `refundChain` and `refundAddress` as parameters\r\n   *\r\n   * @param targetChain in Wormhole Chain ID format\r\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\r\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n   * @param gasLimit gas limit with which to call `targetAddress`.\r\n   * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\r\n   * @return sequence sequence number of published VAA containing delivery instructions\r\n   */\r\n  function sendVaasToEvm(\r\n    uint16 targetChain,\r\n    address targetAddress,\r\n    bytes memory payload,\r\n    uint256 receiverValue,\r\n    uint256 gasLimit,\r\n    VaaKey[] memory vaaKeys\r\n  ) external payable returns (uint64 sequence);\r\n\r\n  /**\r\n   * @notice Publishes an instruction for the default delivery provider\r\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\r\n   * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\r\n   *\r\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\r\n   * `targetAddress` must implement the IWormholeReceiver interface\r\n   *\r\n   * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\r\n   *\r\n   * @param targetChain in Wormhole Chain ID format\r\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\r\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n   * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\r\n   *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\r\n   * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\r\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\r\n   * @param refundAddress The address on `refundChain` to deliver any refund to\r\n   * @return sequence sequence number of published VAA containing delivery instructions\r\n   */\r\n  function sendVaasToEvm(\r\n    uint16 targetChain,\r\n    address targetAddress,\r\n    bytes memory payload,\r\n    uint256 receiverValue,\r\n    uint256 gasLimit,\r\n    VaaKey[] memory vaaKeys,\r\n    uint16 refundChain,\r\n    address refundAddress\r\n  ) external payable returns (uint64 sequence);\r\n\r\n  /**\r\n   * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\r\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\r\n   * with gas limit `gasLimit` and `msg.value` equal to\r\n   * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\r\n   *\r\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\r\n   * `targetAddress` must implement the IWormholeReceiver interface\r\n   *\r\n   * This function must be called with `msg.value` equal to\r\n   * quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit, deliveryProviderAddress) + paymentForExtraReceiverValue\r\n   *\r\n   * @param targetChain in Wormhole Chain ID format\r\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\r\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n   * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\r\n   *        (in addition to the `receiverValue` specified)\r\n   * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\r\n   *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\r\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\r\n   * @param refundAddress The address on `refundChain` to deliver any refund to\r\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n   * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\r\n   * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\r\n   *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\r\n   * @return sequence sequence number of published VAA containing delivery instructions\r\n   */\r\n  function sendToEvm(\r\n    uint16 targetChain,\r\n    address targetAddress,\r\n    bytes memory payload,\r\n    uint256 receiverValue,\r\n    uint256 paymentForExtraReceiverValue,\r\n    uint256 gasLimit,\r\n    uint16 refundChain,\r\n    address refundAddress,\r\n    address deliveryProviderAddress,\r\n    VaaKey[] memory vaaKeys,\r\n    uint8 consistencyLevel\r\n  ) external payable returns (uint64 sequence);\r\n\r\n  /**\r\n   * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\r\n   * to relay a payload and external messages specified by `messageKeys` to the address `targetAddress` on chain `targetChain`\r\n   * with gas limit `gasLimit` and `msg.value` equal to\r\n   * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\r\n   *\r\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\r\n   * `targetAddress` must implement the IWormholeReceiver interface\r\n   *\r\n   * This function must be called with `msg.value` equal to\r\n   * quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit, deliveryProviderAddress) + paymentForExtraReceiverValue\r\n   *\r\n   * Note: MessageKeys can specify wormhole messages (VaaKeys) or other types of messages (ex. USDC CCTP attestations). Ensure the selected\r\n   * DeliveryProvider supports all the MessageKey.keyType values specified or it will not be delivered!\r\n   *\r\n   * @param targetChain in Wormhole Chain ID format\r\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\r\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n   * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\r\n   *        (in addition to the `receiverValue` specified)\r\n   * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\r\n   *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\r\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\r\n   * @param refundAddress The address on `refundChain` to deliver any refund to\r\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n   * @param messageKeys Additional messagess to pass in as parameter in call to `targetAddress`\r\n   * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\r\n   *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\r\n   * @return sequence sequence number of published VAA containing delivery instructions\r\n   */\r\n  function sendToEvm(\r\n    uint16 targetChain,\r\n    address targetAddress,\r\n    bytes memory payload,\r\n    uint256 receiverValue,\r\n    uint256 paymentForExtraReceiverValue,\r\n    uint256 gasLimit,\r\n    uint16 refundChain,\r\n    address refundAddress,\r\n    address deliveryProviderAddress,\r\n    MessageKey[] memory messageKeys,\r\n    uint8 consistencyLevel\r\n  ) external payable returns (uint64 sequence);\r\n\r\n  /**\r\n   * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\r\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\r\n   * with `msg.value` equal to\r\n   * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\r\n   *\r\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\r\n   * `targetAddress` must implement the IWormholeReceiver interface\r\n   *\r\n   * This function must be called with `msg.value` equal to\r\n   * quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress) + paymentForExtraReceiverValue\r\n   *\r\n   * @param targetChain in Wormhole Chain ID format\r\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\r\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n   * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\r\n   *        (in addition to the `receiverValue` specified)\r\n   * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\r\n   *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\r\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\r\n   * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\r\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n   * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\r\n   * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\r\n   *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\r\n   * @return sequence sequence number of published VAA containing delivery instructions\r\n   */\r\n  function send(\r\n    uint16 targetChain,\r\n    bytes32 targetAddress,\r\n    bytes memory payload,\r\n    uint256 receiverValue,\r\n    uint256 paymentForExtraReceiverValue,\r\n    bytes memory encodedExecutionParameters,\r\n    uint16 refundChain,\r\n    bytes32 refundAddress,\r\n    address deliveryProviderAddress,\r\n    VaaKey[] memory vaaKeys,\r\n    uint8 consistencyLevel\r\n  ) external payable returns (uint64 sequence);\r\n\r\n  /**\r\n   * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\r\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\r\n   * with `msg.value` equal to\r\n   * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\r\n   *\r\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\r\n   * `targetAddress` must implement the IWormholeReceiver interface\r\n   *\r\n   * This function must be called with `msg.value` equal to\r\n   * quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress) + paymentForExtraReceiverValue\r\n   *\r\n   * Note: MessageKeys can specify wormhole messages (VaaKeys) or other types of messages (ex. USDC CCTP attestations). Ensure the selected\r\n   * DeliveryProvider supports all the MessageKey.keyType values specified or it will not be delivered!\r\n   *\r\n   * @param targetChain in Wormhole Chain ID format\r\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\r\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\r\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n   * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\r\n   *        (in addition to the `receiverValue` specified)\r\n   * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\r\n   *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\r\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\r\n   * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\r\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n   * @param messageKeys Additional messagess to pass in as parameter in call to `targetAddress`\r\n   * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\r\n   *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\r\n   * @return sequence sequence number of published VAA containing delivery instructions\r\n   */\r\n  function send(\r\n    uint16 targetChain,\r\n    bytes32 targetAddress,\r\n    bytes memory payload,\r\n    uint256 receiverValue,\r\n    uint256 paymentForExtraReceiverValue,\r\n    bytes memory encodedExecutionParameters,\r\n    uint16 refundChain,\r\n    bytes32 refundAddress,\r\n    address deliveryProviderAddress,\r\n    MessageKey[] memory messageKeys,\r\n    uint8 consistencyLevel\r\n  ) external payable returns (uint64 sequence);\r\n\r\n  /**\r\n   * @notice Requests a previously published delivery instruction to be redelivered\r\n   * (e.g. with a different delivery provider)\r\n   *\r\n   * This function must be called with `msg.value` equal to\r\n   * quoteEVMDeliveryPrice(targetChain, newReceiverValue, newGasLimit, newDeliveryProviderAddress)\r\n   *\r\n   *  @notice *** This will only be able to succeed if the following is true **\r\n   *         - newGasLimit >= gas limit of the old instruction\r\n   *         - newReceiverValue >= receiver value of the old instruction\r\n   *         - newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\r\n   *\r\n   * @param deliveryVaaKey VaaKey identifying the wormhole message containing the\r\n   *        previously published delivery instructions\r\n   * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\r\n   * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n   * @param newGasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\r\n   *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider, to the refund chain and address specified in the original request\r\n   * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n   * @return sequence sequence number of published VAA containing redelivery instructions\r\n   *\r\n   * @notice *** This will only be able to succeed if the following is true **\r\n   *         - newGasLimit >= gas limit of the old instruction\r\n   *         - newReceiverValue >= receiver value of the old instruction\r\n   */\r\n  function resendToEvm(\r\n    VaaKey memory deliveryVaaKey,\r\n    uint16 targetChain,\r\n    uint256 newReceiverValue,\r\n    uint256 newGasLimit,\r\n    address newDeliveryProviderAddress\r\n  ) external payable returns (uint64 sequence);\r\n\r\n  /**\r\n   * @notice Requests a previously published delivery instruction to be redelivered\r\n   *\r\n   *\r\n   * This function must be called with `msg.value` equal to\r\n   * quoteDeliveryPrice(targetChain, newReceiverValue, newEncodedExecutionParameters, newDeliveryProviderAddress)\r\n   *\r\n   * @param deliveryVaaKey VaaKey identifying the wormhole message containing the\r\n   *        previously published delivery instructions\r\n   * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\r\n   * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n   * @param newEncodedExecutionParameters new encoded information on how to execute delivery that may impact pricing\r\n   *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\r\n   * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n   * @return sequence sequence number of published VAA containing redelivery instructions\r\n   *\r\n   *  @notice *** This will only be able to succeed if the following is true **\r\n   *         - (For EVM_V1) newGasLimit >= gas limit of the old instruction\r\n   *         - newReceiverValue >= receiver value of the old instruction\r\n   *         - (For EVM_V1) newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\r\n   */\r\n  function resend(\r\n    VaaKey memory deliveryVaaKey,\r\n    uint16 targetChain,\r\n    uint256 newReceiverValue,\r\n    bytes memory newEncodedExecutionParameters,\r\n    address newDeliveryProviderAddress\r\n  ) external payable returns (uint64 sequence);\r\n\r\n  /**\r\n   * @notice Returns the price to request a relay to chain `targetChain`, using the default delivery provider\r\n   *\r\n   * @param targetChain in Wormhole Chain ID format\r\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n   * @param gasLimit gas limit with which to call `targetAddress`.\r\n   * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\r\n   * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused,\r\n   *         if a refundAddress is specified.\r\n   *         Note: This value can be overridden by the delivery provider on the target chain. The returned value here should be considered to be a\r\n   *         promise by the delivery provider of the amount of refund per gas unused that will be returned to the refundAddress at the target chain.\r\n   *         If a delivery provider decides to override, this will be visible as part of the emitted Delivery event on the target chain.\r\n   */\r\n  function quoteEVMDeliveryPrice(\r\n    uint16 targetChain,\r\n    uint256 receiverValue,\r\n    uint256 gasLimit\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n        uint256 nativePriceQuote,\r\n        uint256 targetChainRefundPerGasUnused\r\n    );\r\n\r\n  /**\r\n   * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\r\n   *\r\n   * @param targetChain in Wormhole Chain ID format\r\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n   * @param gasLimit gas limit with which to call `targetAddress`.\r\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n   * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\r\n   * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused,\r\n   *         if a refundAddress is specified\r\n   *         Note: This value can be overridden by the delivery provider on the target chain. The returned value here should be considered to be a\r\n   *         promise by the delivery provider of the amount of refund per gas unused that will be returned to the refundAddress at the target chain.\r\n   *         If a delivery provider decides to override, this will be visible as part of the emitted Delivery event on the target chain.\r\n   */\r\n  function quoteEVMDeliveryPrice(\r\n    uint16 targetChain,\r\n    uint256 receiverValue,\r\n    uint256 gasLimit,\r\n    address deliveryProviderAddress\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n        uint256 nativePriceQuote,\r\n        uint256 targetChainRefundPerGasUnused\r\n    );\r\n\r\n  /**\r\n   * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\r\n   *\r\n   * @param targetChain in Wormhole Chain ID format\r\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\r\n   * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\r\n   *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\r\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n   * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\r\n   * @return encodedExecutionInfo encoded information on how the delivery will be executed\r\n   *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` and `targetChainRefundPerGasUnused`\r\n   *             (which is the amount of target chain currency that will be refunded per unit of gas unused,\r\n   *              if a refundAddress is specified)\r\n   */\r\n  function quoteDeliveryPrice(\r\n    uint16 targetChain,\r\n    uint256 receiverValue,\r\n    bytes memory encodedExecutionParameters,\r\n    address deliveryProviderAddress\r\n  )\r\n    external\r\n    view\r\n    returns (uint256 nativePriceQuote, bytes memory encodedExecutionInfo);\r\n\r\n  /**\r\n   * @notice Returns the (extra) amount of target chain currency that `targetAddress`\r\n   * will be called with, if the `paymentForExtraReceiverValue` field is set to `currentChainAmount`\r\n   *\r\n   * @param targetChain in Wormhole Chain ID format\r\n   * @param currentChainAmount The value that `paymentForExtraReceiverValue` will be set to\r\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\r\n   * @return targetChainAmount The amount such that if `targetAddress` will be called with `msg.value` equal to\r\n   *         receiverValue + targetChainAmount\r\n   */\r\n  function quoteNativeForChain(\r\n    uint16 targetChain,\r\n    uint256 currentChainAmount,\r\n    address deliveryProviderAddress\r\n  ) external view returns (uint256 targetChainAmount);\r\n\r\n  /**\r\n   * @notice Returns the address of the current default delivery provider\r\n   * @return deliveryProvider The address of (the default delivery provider)'s contract on this source\r\n   *   chain. This must be a contract that implements IDeliveryProvider.\r\n   */\r\n  function getDefaultDeliveryProvider()\r\n    external\r\n    view\r\n    returns (address deliveryProvider);\r\n}\r\n\r\n/**\r\n * @title IWormholeRelayerDelivery\r\n * @notice The interface to execute deliveries. Only relevant for Delivery Providers\r\n */\r\ninterface IWormholeRelayerDelivery is IWormholeRelayerBase {\r\n  enum DeliveryStatus {\r\n    SUCCESS,\r\n    RECEIVER_FAILURE\r\n  }\r\n\r\n  enum RefundStatus {\r\n    REFUND_SENT,\r\n    REFUND_FAIL,\r\n    CROSS_CHAIN_REFUND_SENT,\r\n    CROSS_CHAIN_REFUND_FAIL_PROVIDER_NOT_SUPPORTED,\r\n    CROSS_CHAIN_REFUND_FAIL_NOT_ENOUGH,\r\n    NO_REFUND_REQUESTED\r\n  }\r\n\r\n  /**\r\n   * @custom:member recipientContract - The target contract address\r\n   * @custom:member sourceChain - The chain which this delivery was requested from (in wormhole\r\n   *     ChainID format)\r\n   * @custom:member sequence - The wormhole sequence number of the delivery VAA on the source chain\r\n   *     corresponding to this delivery request\r\n   * @custom:member deliveryVaaHash - The hash of the delivery VAA corresponding to this delivery\r\n   *     request\r\n   * @custom:member gasUsed - The amount of gas that was used to call your target contract\r\n   * @custom:member status:\r\n   *   - RECEIVER_FAILURE, if the target contract reverts\r\n   *   - SUCCESS, if the target contract doesn't revert\r\n   * @custom:member additionalStatusInfo:\r\n   *   - If status is SUCCESS, then this is empty.\r\n   *   - If status is RECEIVER_FAILURE, this is `RETURNDATA_TRUNCATION_THRESHOLD` bytes of the\r\n   *       return data (i.e. potentially truncated revert reason information).\r\n   * @custom:member refundStatus - Result of the refund. REFUND_SUCCESS or REFUND_FAIL are for\r\n   *     refunds where targetChain=refundChain; the others are for targetChain!=refundChain,\r\n   *     where a cross chain refund is necessary, or if the default code path is used where no refund is requested (NO_REFUND_REQUESTED)\r\n   * @custom:member overridesInfo:\r\n   *   - If not an override: empty bytes array\r\n   *   - Otherwise: An encoded `DeliveryOverride`\r\n   */\r\n  event Delivery(\r\n    address indexed recipientContract,\r\n    uint16 indexed sourceChain,\r\n    uint64 indexed sequence,\r\n    bytes32 deliveryVaaHash,\r\n    DeliveryStatus status,\r\n    uint256 gasUsed,\r\n    RefundStatus refundStatus,\r\n    bytes additionalStatusInfo,\r\n    bytes overridesInfo\r\n  );\r\n\r\n  /**\r\n   * @notice The delivery provider calls `deliver` to relay messages as described by one delivery instruction\r\n   *\r\n   * The delivery provider must pass in the specified (by VaaKeys[]) signed wormhole messages (VAAs) from the source chain\r\n   * as well as the signed wormhole message with the delivery instructions (the delivery VAA)\r\n   *\r\n   * The messages will be relayed to the target address (with the specified gas limit and receiver value) iff the following checks are met:\r\n   * - the delivery VAA has a valid signature\r\n   * - the delivery VAA's emitter is one of these WormholeRelayer contracts\r\n   * - the delivery provider passed in at least enough of this chain's currency as msg.value (enough meaning the maximum possible refund)\r\n   * - the instruction's target chain is this chain\r\n   * - the relayed signed VAAs match the descriptions in container.messages (the VAA hashes match, or the emitter address, sequence number pair matches, depending on the description given)\r\n   *\r\n   * @param encodedVMs - An array of signed wormhole messages (all from the same source chain\r\n   *     transaction)\r\n   * @param encodedDeliveryVAA - Signed wormhole message from the source chain's WormholeRelayer\r\n   *     contract with payload being the encoded delivery instruction container\r\n   * @param relayerRefundAddress - The address to which any refunds to the delivery provider\r\n   *     should be sent\r\n   * @param deliveryOverrides - Optional overrides field which must be either an empty bytes array or\r\n   *     an encoded DeliveryOverride struct\r\n   */\r\n  function deliver(\r\n    bytes[] memory encodedVMs,\r\n    bytes memory encodedDeliveryVAA,\r\n    address payable relayerRefundAddress,\r\n    bytes memory deliveryOverrides\r\n  ) external payable;\r\n}\r\n\r\ninterface IWormholeRelayer is IWormholeRelayerDelivery, IWormholeRelayerSend {}\r\n\r\n/*\r\n *  Errors thrown by IWormholeRelayer contract\r\n */\r\n\r\n// Bound chosen by the following formula: `memoryWord * 4 + selectorSize`.\r\n// This means that an error identifier plus four fixed size arguments should be available to developers.\r\n// In the case of a `require` revert with error message, this should provide 2 memory word's worth of data.\r\nuint256 constant RETURNDATA_TRUNCATION_THRESHOLD = 132;\r\n\r\n//When msg.value was not equal to `delivery provider's quoted delivery price` + `paymentForExtraReceiverValue`\r\nerror InvalidMsgValue(uint256 msgValue, uint256 totalFee);\r\n\r\nerror RequestedGasLimitTooLow();\r\n\r\nerror DeliveryProviderDoesNotSupportTargetChain(\r\n  address relayer,\r\n  uint16 chainId\r\n);\r\nerror DeliveryProviderCannotReceivePayment();\r\nerror DeliveryProviderDoesNotSupportMessageKeyType(uint8 keyType);\r\n\r\n//When calling `delivery()` a second time even though a delivery is already in progress\r\nerror ReentrantDelivery(address msgSender, address lockedBy);\r\n\r\nerror InvalidPayloadId(uint8 parsed, uint8 expected);\r\nerror InvalidPayloadLength(uint256 received, uint256 expected);\r\nerror InvalidVaaKeyType(uint8 parsed);\r\nerror TooManyMessageKeys(uint256 numMessageKeys);\r\n\r\nerror InvalidDeliveryVaa(string reason);\r\n//When the delivery VAA (signed wormhole message with delivery instructions) was not emitted by the\r\n//  registered WormholeRelayer contract\r\nerror InvalidEmitter(bytes32 emitter, bytes32 registered, uint16 chainId);\r\nerror MessageKeysLengthDoesNotMatchMessagesLength(uint256 keys, uint256 vaas);\r\nerror VaaKeysDoNotMatchVaas(uint8 index);\r\n//When someone tries to call an external function of the WormholeRelayer that is only intended to be\r\n//  called by the WormholeRelayer itself (to allow retroactive reverts for atomicity)\r\nerror RequesterNotWormholeRelayer();\r\n\r\n//When trying to relay a `DeliveryInstruction` to any other chain but the one it was specified for\r\nerror TargetChainIsNotThisChain(uint16 targetChain);\r\n//When a `DeliveryOverride` contains a gas limit that's less than the original\r\nerror InvalidOverrideGasLimit();\r\n//When a `DeliveryOverride` contains a receiver value that's less than the original\r\nerror InvalidOverrideReceiverValue();\r\n//When a `DeliveryOverride` contains a 'refund per unit of gas unused' that's less than the original\r\nerror InvalidOverrideRefundPerGasUnused();\r\n\r\n//When the delivery provider doesn't pass in sufficient funds (i.e. msg.value does not cover the\r\n// maximum possible refund to the user)\r\nerror InsufficientRelayerFunds(uint256 msgValue, uint256 minimum);\r\n\r\n//When a bytes32 field can't be converted into a 20 byte EVM address, because the 12 padding bytes\r\n//  are non-zero (see Utils.sol)\r\n//error NotAnEvmAddress(bytes32);"
    },
    "contracts/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonalo S <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      This is a reduced version of the library.\r\n */\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nlibrary BytesLib {\r\n    uint256 private constant freeMemoryPtr = 0x40;\r\n    uint256 private constant maskModulo32 = 0x1f;\r\n    /**\r\n     * Size of word read by `mload` instruction.\r\n     */\r\n    uint256 private constant memoryWord = 32;\r\n    uint256 internal constant uint8Size = 1;\r\n    uint256 internal constant uint16Size = 2;\r\n    uint256 internal constant uint32Size = 4;\r\n    uint256 internal constant uint64Size = 8;\r\n    uint256 internal constant uint128Size = 16;\r\n    uint256 internal constant uint256Size = 32;\r\n    uint256 internal constant addressSize = 20;\r\n    /**\r\n     * Bits in 12 bytes.\r\n     */\r\n    uint256 private constant bytes12Bits = 96;\r\n\r\n    function slice(bytes memory buffer, uint256 startIndex, uint256 length) internal pure returns (bytes memory) {\r\n        unchecked {\r\n            require(length + 31 >= length, \"slice_overflow\");\r\n        }\r\n        require(buffer.length >= startIndex + length, \"slice_outOfBounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly (\"memory-safe\") {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(freeMemoryPtr)\r\n\r\n            switch iszero(length)\r\n            case 0 {\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(length, maskModulo32)\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let startOffset := add(lengthmod, mul(memoryWord, iszero(lengthmod)))\r\n\r\n                let dst := add(tempBytes, startOffset)\r\n                let end := add(dst, length)\r\n\r\n                for { let src := add(add(buffer, startOffset), startIndex) } lt(dst, end) {\r\n                    dst := add(dst, memoryWord)\r\n                    src := add(src, memoryWord)\r\n                } { mstore(dst, mload(src)) }\r\n\r\n                // Update free-memory pointer\r\n                // allocating the array padded to 32 bytes like the compiler does now\r\n                // Note that negating bitwise the `maskModulo32` produces a mask that aligns addressing to 32 bytes.\r\n                mstore(freeMemoryPtr, and(add(dst, maskModulo32), not(maskModulo32)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default { mstore(freeMemoryPtr, add(tempBytes, memoryWord)) }\r\n\r\n            // Store the length of the buffer\r\n            // We need to do it even if the length is zero because Solidity does not garbage collect\r\n            mstore(tempBytes, length)\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory buffer, uint256 startIndex) internal pure returns (address) {\r\n        require(buffer.length >= startIndex + addressSize, \"toAddress_outOfBounds\");\r\n        address tempAddress;\r\n\r\n        assembly (\"memory-safe\") {\r\n            // We want to shift into the lower 12 bytes and leave the upper 12 bytes clear.\r\n            tempAddress := shr(bytes12Bits, mload(add(add(buffer, memoryWord), startIndex)))\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory buffer, uint256 startIndex) internal pure returns (uint8) {\r\n        require(buffer.length > startIndex, \"toUint8_outOfBounds\");\r\n\r\n        // Note that `endIndex == startOffset` for a given buffer due to the 32 bytes at the start that store the length.\r\n        uint256 startOffset = startIndex + uint8Size;\r\n        uint8 tempUint;\r\n        assembly (\"memory-safe\") {\r\n            tempUint := mload(add(buffer, startOffset))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(bytes memory buffer, uint256 startIndex) internal pure returns (uint16) {\r\n        uint256 endIndex = startIndex + uint16Size;\r\n        require(buffer.length >= endIndex, \"toUint16_outOfBounds\");\r\n\r\n        uint16 tempUint;\r\n        assembly (\"memory-safe\") {\r\n            // Note that `endIndex == startOffset` for a given buffer due to the 32 bytes at the start that store the length.\r\n            tempUint := mload(add(buffer, endIndex))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(bytes memory buffer, uint256 startIndex) internal pure returns (uint32) {\r\n        uint256 endIndex = startIndex + uint32Size;\r\n        require(buffer.length >= endIndex, \"toUint32_outOfBounds\");\r\n\r\n        uint32 tempUint;\r\n        assembly (\"memory-safe\") {\r\n            // Note that `endIndex == startOffset` for a given buffer due to the 32 bytes at the start that store the length.\r\n            tempUint := mload(add(buffer, endIndex))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint64(bytes memory buffer, uint256 startIndex) internal pure returns (uint64) {\r\n        uint256 endIndex = startIndex + uint64Size;\r\n        require(buffer.length >= endIndex, \"toUint64_outOfBounds\");\r\n\r\n        uint64 tempUint;\r\n        assembly (\"memory-safe\") {\r\n            // Note that `endIndex == startOffset` for a given buffer due to the 32 bytes at the start that store the length.\r\n            tempUint := mload(add(buffer, endIndex))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint128(bytes memory buffer, uint256 startIndex) internal pure returns (uint128) {\r\n        uint256 endIndex = startIndex + uint128Size;\r\n        require(buffer.length >= endIndex, \"toUint128_outOfBounds\");\r\n\r\n        uint128 tempUint;\r\n        assembly (\"memory-safe\") {\r\n            // Note that `endIndex == startOffset` for a given buffer due to the 32 bytes at the start that store the length.\r\n            tempUint := mload(add(buffer, endIndex))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint256(bytes memory buffer, uint256 startIndex) internal pure returns (uint256) {\r\n        uint256 endIndex = startIndex + uint256Size;\r\n        require(buffer.length >= endIndex, \"toUint256_outOfBounds\");\r\n\r\n        uint256 tempUint;\r\n        assembly (\"memory-safe\") {\r\n            // Note that `endIndex == startOffset` for a given buffer due to the 32 bytes at the start that store the length.\r\n            tempUint := mload(add(buffer, endIndex))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes32(bytes memory buffer, uint256 startIndex) internal pure returns (bytes32) {\r\n        uint256 endIndex = startIndex + uint256Size;\r\n        require(buffer.length >= endIndex, \"toBytes32_outOfBounds\");\r\n\r\n        bytes32 tempBytes32;\r\n        assembly (\"memory-safe\") {\r\n            // Note that `endIndex == startOffset` for a given buffer due to the 32 bytes at the start that store the length.\r\n            tempBytes32 := mload(add(buffer, endIndex))\r\n        }\r\n        return tempBytes32;\r\n    }\r\n}\r\n"
    },
    "contracts/Policy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\r\npragma solidity ^0.8.27;\r\nimport \"./interfaces/IPolicy.sol\";\r\n\r\ncontract Policy is IPolicy {\r\n    \r\n    address internal _policy;\r\n    address internal _newPolicy;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        _policy = msg.sender;\r\n        emit OwnershipTransferred( address(0), _policy );\r\n    }\r\n\r\n    function policy() public view override returns (address) {\r\n        return _policy;\r\n    }\r\n\r\n    modifier onlyPolicy() {\r\n        require( _policy == msg.sender, \"Ownable: caller is not the owner\" );\r\n        _;\r\n    }\r\n\r\n    function renouncePolicy() public virtual override onlyPolicy() {\r\n        emit OwnershipTransferred( _policy, address(0) );\r\n        _policy = address(0);\r\n    }\r\n\r\n    function pushPolicy( address newPolicy_ ) public virtual override onlyPolicy() {\r\n        require( newPolicy_ != address(0), \"Ownable: new owner is the zero address\");\r\n        _newPolicy = newPolicy_;\r\n    }\r\n\r\n    function pullPolicy() public virtual override {\r\n        require( msg.sender == _newPolicy );\r\n        emit OwnershipTransferred( _policy, _newPolicy );\r\n        _policy = _newPolicy;\r\n    }\r\n}"
    },
    "contracts/WormholeBridge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.27;\r\n\r\nimport \"./interfaces/IWormhole.sol\";\r\nimport \"./Policy.sol\";\r\nimport \"./libraries/BytesLib.sol\";\r\nimport \"./interfaces/ITokenBridge.sol\";\r\nimport \"./interfaces/IWormholeRelayer.sol\";\r\nimport \"./interfaces/IWormholeReceiver.sol\";\r\nimport \"./interfaces/ICircleIntegration.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ncontract WormholeBridge is Policy, IWormholeReceiver {\r\n    using SafeERC20 for IERC20;\r\n    using BytesLib for bytes;\r\n\r\n    uint32 private NONCE;\r\n    uint8 public constant CONSISTENCY_LEVEL = 200;\r\n    uint256 public constant GAS_LIMIT = 1_000_000;\r\n    uint64 private minSequence = 0;\r\n    /**\r\n     * Message timeout in seconds: Time out needs to account for:\r\n     * - Finality time on source chain\r\n     * - Time for Wormhole validators to sign and make VAA available to relayers\r\n     * - Time to relay VAA to the target chain\r\n     * - Congestion on target chain leading to delayed inclusion of transaction in target chain\r\n     *\r\n     * Note that there is no way to alter this hard coded value. Including such a feature\r\n     * would require some governance structure and some minumum and maximum values.\r\n     */\r\n    uint256 public constant MESSAGE_TIME_OUT_SECONDS = 2 days;\r\n\r\n    IWormhole public immutable wormhole;\r\n    ITokenBridge public immutable tokenBridge;\r\n    IWormholeRelayer public immutable relayer;\r\n    ICircleIntegration public immutable circleIntegration;\r\n    mapping(address => mapping (address => uint256)) locked;\r\n    mapping(uint16 => bytes32) registeredSenders;\r\n\r\n    struct Message {\r\n        uint8 payloadID;\r\n        bytes message;\r\n    }\r\n\r\n    struct TokenTransfer {\r\n        uint8 payloadID;\r\n        bytes32 recipient;\r\n    }\r\n\r\n    event TransferToken(address indexed token, uint256 amount);\r\n    event ReceiveMessage(address sender, uint16 sourceChain, bytes32 sourceAddress);\r\n\r\n    constructor(address _wormhole, address _tokenBridge, address _wormholeRelayer, address _circleIntegration) Policy() {\r\n        require(_wormhole != address(0), \"ZA\");\r\n        wormhole = IWormhole(_wormhole);\r\n        require(_tokenBridge != address(0), \"ZA\");\r\n        tokenBridge = ITokenBridge(_tokenBridge);\r\n        relayer = IWormholeRelayer(_wormholeRelayer);\r\n        circleIntegration = ICircleIntegration(_circleIntegration);\r\n        NONCE = 0;\r\n    }\r\n\r\n    modifier onlyRelayer() {\r\n        require(msg.sender == address(relayer), \"Not relayer\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to check if the sender is registered for the source chain\r\n    modifier isRegisteredSender(uint16 sourceChain, bytes32 sourceAddress) {\r\n        require(registeredSenders[sourceChain] == sourceAddress, \"Not registered sender\");\r\n        _;\r\n    }\r\n\r\n    // Function to register the valid sender address for a specific chain\r\n    function registerSender(uint16 sourceChain, bytes32 sourceAddress) external onlyPolicy {\r\n        registeredSenders[sourceChain] = sourceAddress;\r\n    }\r\n\r\n    function sendMessageToSolana(\r\n        address _bettingToken,\r\n        uint64 _amount,\r\n        uint64 _marketId,\r\n        uint64 _answerId\r\n    ) external payable returns(uint64 sequence) {\r\n        uint256 messageFee = wormhole.messageFee();\r\n        require(msg.value >= messageFee, \"Insufficient funds for cross-chain delivery\");\r\n        IERC20(_bettingToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n        locked[msg.sender][_bettingToken] = _amount;\r\n        bytes memory messagePayload = abi.encodePacked(\r\n            _marketId,\r\n            _answerId,\r\n            uint64(block.timestamp),\r\n            wormhole.chainId(),\r\n            bytes32(bytes20(msg.sender)),\r\n            bytes32(bytes20(_bettingToken)),\r\n            _amount\r\n        );\r\n        Message memory parsedMessage = Message({\r\n            payloadID: 1,\r\n            message: messagePayload\r\n        });\r\n\r\n        bytes memory encodeMessage = abi.encodePacked(\r\n            parsedMessage.payloadID,\r\n            uint16(parsedMessage.message.length),\r\n            parsedMessage.message\r\n        );\r\n\r\n        sequence = wormhole.publishMessage{value: messageFee}(\r\n            NONCE++, \r\n            encodeMessage,\r\n            CONSISTENCY_LEVEL\r\n        );\r\n    }\r\n\r\n    function receiveSolanaMessage(bytes calldata _whMessage) external payable {\r\n        (IWormhole.VM memory vm, bool valid, string memory reason) = wormhole.parseAndVerifyVM(_whMessage);\r\n        require(valid, reason);\r\n        require(registeredSenders[vm.emitterChainId] == vm.emitterAddress, \"Invalid Emitter Address!\");\r\n\r\n        /**\r\n         * Ensure that the sequence field in the VAA is strictly monotonically increasing. This also acts as\r\n         * a replay protection mechanism to ensure that already executed messages don't execute again.\r\n         */\r\n        require(vm.sequence >= minSequence, \"Invalid Sequence number\");\r\n        minSequence = vm.sequence + 1;\r\n\r\n        // check if the message is still valid as defined by the validity period\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(vm.timestamp + MESSAGE_TIME_OUT_SECONDS >= block.timestamp, \"Message no longer valid\");\r\n\r\n        (\r\n            address voter,\r\n            address bettingToken,\r\n            uint256 amount,\r\n            uint16 receiverChainId,\r\n            bytes32 receiverAddress\r\n        ) = abi.decode(vm.payload, (address, address, uint256, uint16, bytes32));\r\n        require(receiverChainId == wormhole.chainId(), \"Wrong chain Id\");\r\n        require(receiverAddress == bytes32(bytes20(address(this))), \"Wrong address\");\r\n\r\n        uint256 lockedAmount = locked[voter][bettingToken];\r\n        require(lockedAmount >= amount, \"Invalid amount\");\r\n        locked[voter][bettingToken] -= amount;\r\n        IERC20(bettingToken).safeTransfer(voter, amount);\r\n        emit TransferToken(bettingToken, amount);\r\n    }\r\n\r\n    function sendMessageToEvm(\r\n        address _bettingToken,\r\n        uint256 _amount,\r\n        uint256 _marketId,\r\n        uint256 _answerId,\r\n        uint256 _bettingKey,\r\n        uint16 targetChain,\r\n        address targetAddress    \r\n    ) external payable {\r\n        (uint256 cost, ) = relayer.quoteEVMDeliveryPrice(targetChain, 0, GAS_LIMIT); // Dynamically calculate the cross-chain cost\r\n        require(msg.value >= cost, \"Insufficient funds for cross-chain delivery\");\r\n\r\n        bytes memory messagePayload = abi.encode(\r\n            _marketId,\r\n            _answerId,\r\n            _bettingKey,\r\n            block.timestamp,\r\n            bytes32(bytes20(msg.sender)),\r\n            bytes32(bytes20(_bettingToken)),\r\n            _amount\r\n        );\r\n        relayer.sendPayloadToEvm{value: cost}(\r\n            targetChain,\r\n            targetAddress,\r\n            abi.encode(messagePayload, msg.sender), // Payload contains the message and sender address\r\n            0, // No receiver value needed\r\n            GAS_LIMIT // Gas limit for the transaction\r\n        );\r\n    }\r\n\r\n    function receiveWormholeMessages(\r\n    bytes memory payload,\r\n    bytes[] memory,\r\n    bytes32 sourceAddress,\r\n    uint16 sourceChain,\r\n    bytes32\r\n  ) external payable onlyRelayer isRegisteredSender(sourceChain, sourceAddress) {\r\n    (, , , , bytes32 voter, , ) = abi.decode(payload, (uint256, uint256, uint256, uint256, bytes32, bytes32, uint256));\r\n    emit ReceiveMessage(address(uint160(uint256(voter))), sourceChain, sourceAddress);\r\n  }\r\n\r\n    function transferCrossChain(\r\n        address _recipient, \r\n        address _bettingToken, \r\n        uint64 _amount,\r\n        uint16 _targetChain,\r\n        bytes32 _targetAddress\r\n    ) external payable {\r\n        uint256 messageFee = wormhole.messageFee();\r\n        require(msg.value >= messageFee, \"Invalid msg value\");\r\n        IERC20(_bettingToken).safeTransferFrom(msg.sender, address(this), _amount);        \r\n        tokenBridge.transferTokensWithPayload(\r\n            _bettingToken,\r\n            _amount,\r\n            _targetChain,\r\n            _targetAddress,\r\n            NONCE,\r\n            abi.encode(_recipient)\r\n        );\r\n    }\r\n\r\n    function redeemTransferWithPayload(bytes memory encodedVM) public {\r\n        IWormhole.VM memory vm = wormhole.parseVM(\r\n            encodedVM\r\n        );\r\n\r\n        ITokenBridge.TransferWithPayload memory transfer = tokenBridge.parseTransferWithPayload(vm.payload);\r\n        address localTokenAddress = tokenBridge.wrappedAsset(transfer.tokenChain, transfer.tokenAddress);\r\n        if(transfer.tokenChain == 1 && localTokenAddress == address(0)) {\r\n            bytes32 usdcAddress = circleIntegration.fetchLocalTokenAddress(5, transfer.tokenAddress);\r\n            localTokenAddress = address(uint160(uint256(usdcAddress)));\r\n        }\r\n        require(localTokenAddress != address(0), \"token not attested\");\r\n\r\n        tokenBridge.completeTransferWithPayload(\r\n            encodedVM\r\n        );\r\n        uint256 amountTransferred = transfer.amount;\r\n\r\n        require(registeredSenders[vm.emitterChainId] == vm.emitterAddress, \"Invalid Emitter Address!\");\r\n\r\n        TokenTransfer memory payload = decodePayload(\r\n            transfer.payload\r\n        );\r\n\r\n        address recipient = address(uint160(uint256(payload.recipient)));\r\n        IERC20(localTokenAddress).safeTransfer(\r\n            recipient,\r\n            amountTransferred\r\n        );\r\n    }\r\n\r\n    function decodePayload(\r\n        bytes memory encodedMessage\r\n    ) public pure returns (TokenTransfer memory parsedMessage) {\r\n        uint256 index = 0;\r\n        parsedMessage.payloadID = encodedMessage.toUint8(index);\r\n        require(parsedMessage.payloadID == 1, \"invalid payloadID\");\r\n        index += 1;\r\n        parsedMessage.recipient = encodedMessage.toBytes32(index);\r\n        index += 32;\r\n        require(index == encodedMessage.length, \"invalid payload length\");\r\n    }\r\n\r\n    function quoteEVMDeliveryCost(uint16 targetChain) external view returns(uint256 cost) {\r\n        (cost, ) = relayer.quoteEVMDeliveryPrice(targetChain, 0, GAS_LIMIT);\r\n    }\r\n    function getMessageFee() external view returns(uint256) {\r\n        return wormhole.messageFee();\r\n    }\r\n\r\n    function getWormholeChainId() external view returns(uint16) {\r\n        return wormhole.chainId();\r\n    }\r\n\r\n    function getSourceAddress(bytes32 tokenAddress, uint16 sourceChain) external view returns(address) {\r\n        uint32 sourceDomain = circleIntegration.getDomainFromChainId(sourceChain);\r\n        return address(uint160(uint256(circleIntegration.fetchLocalTokenAddress(sourceDomain, tokenAddress))));\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 0
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}